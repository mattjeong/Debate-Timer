<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>AP Debate Timer — HTML</title>
<style>
  button { touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
  :root{
    --bg-green:#d1fae5; --fg-green:#064e3b; --bd-green:#34d399;
    --bg-yellow:#fef3c7; --fg-yellow:#92400e; --bd-yellow:#f59e0b;
    --bg-red:#fecaca; --fg-red:#7f1d1d; --bd-red:#f87171;
    --bg-card:#ffffff; --bd:#e5e7eb; --fg:#111827; --muted:#6b7280;
    --track:#e5e7eb; --fill:#111827;
  }
  html,body{height:100%}
  body{margin:0;font:16px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:24px;padding:24px;transition:background-color .25s,color .25s}
  .container{width:100%;max-width:1000px;display:flex;flex-direction:column;gap:16px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  h1{font-size:24px;margin:0}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .btn{appearance:none;border:1px solid var(--bd);background:#fff;border-radius:12px;padding:10px 14px;cursor:pointer;display:inline-flex;align-items:center;gap:8px;font-weight:600}
  .btn:active{transform:translateY(1px)}
  .card{background:var(--bg-card);border:1px solid var(--bd);border-radius:16px;padding:16px}
  .title{font-weight:700}
  .muted{color:var(--muted)}
  .clock{font-size:76px;font-weight:900;text-align:center}
  .progress{height:12px;background:var(--track);border-radius:999px;position:relative;overflow:hidden}
  .fill{position:absolute;left:0;top:0;bottom:0;background:var(--fill)}
  .seg{outline:1px solid rgba(0,0,0,0.12);height:100%}
  .grid{display:grid;gap:12px}
  .grid-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .input{padding:8px 10px;border:1px solid var(--bd);border-radius:10px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  .label{display:flex;flex-direction:column;gap:6px}
  .bar{height:8px;background:rgba(17,24,39,.12);border-radius:8px;overflow:hidden}
  .bar>.bfill{height:100%;background:#111827}
  .caps{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:6px;margin-top:6px;color:#475569;font-size:12px}
  .tests li{margin:2px 0}
  .note{font-size:12px;color:#6b7280;margin-top:6px;text-align:center}

  /* Speaker Progress Bar Styles */
  .speaker-progress-bar {
    display: grid;
    grid-template-columns: repeat(14, 1fr); /* 14 slots for speakers + preps */
    gap: 4px;
    border-radius: 8px;
    background-color: var(--track);
    padding: 4px;
  }
  .speaker-box {
    font-size: 11px;
    font-weight: 700;
    padding: 8px 4px;
    border-radius: 6px;
    text-align: center;
    background-color: #fff;
    border: 1px solid var(--bd);
    cursor: grab;
    user-select: none;
    transition: background-color 0.2s, box-shadow 0.2s, opacity 0.2s;
  }
  .speaker-box:active { cursor: grabbing; }
  .speaker-box.team-prop { color: #15803d; border-color: #86efac; }
  .speaker-box.team-opp { color: #b91c1c; border-color: #fca5a5; }
  .speaker-box.team-none { color: #374151; border-color: #d1d5db; }
  .speaker-box.active-speaker {
    box-shadow: 0 0 0 3px var(--fg, #111827);
    font-weight: 900;
  }
  
  /* New styles for drag/drop and inactive */
  .speaker-box.dragging {
    opacity: 0.5;
    background: #e0f2fe;
  }
  .speaker-box.drag-over {
    background: #fef9c3;
    border-style: dashed;
  }
  .speaker-box.inactive {
    opacity: 0.4;
    background: #f3f4f6;
    text-decoration: line-through;
    cursor: not-allowed;
  }

  @media (max-width:800px){.grid-3{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div id="app" class="wrap">
    <div class="container">
      <header>
        <h1>Debate Timer</h1>
        <div class="row">
          <button id="muteBtn" class="btn">Sound</button>
          <button id="enableBtn" class="btn">Enable Sound</button>
          <button id="testsBtn" class="btn">Tests</button>
        </div>
      </header>

      <!-- Speaker Progress -->
      <div class="card">
        <div class="title" style="margin-bottom:8px">Speaker Progress</div>
        <div class="speaker-progress-bar" id="speakerProgress">
          <!-- Speakers will be generated by JS -->
        </div>
        <div class="row" style="justify-content:space-between;margin-top:8px">
          <div>
            <button id="prevSpeakerBtn" class="btn">Previous</button>
            <button id="nextSpeakerBtn" class="btn">Next</button>
          </div>
          <!-- Prep timer is part of this card -->
          <div id="prepTimerContainer" class="row">
            <input id="prepInput" class="input" value="20:00" style="width:60px" />
            <div class.clock" id="prepClock" style="font-size:20px;font-weight:700;padding:0 8px">20:00</div>
            <button id="prepStart" class="btn">Start</button>
            <button id="prepReset" class="btn">Reset</button>
          </div>
          <button id="resetOrderBtn" class="btn">Reset Order</button>
        </div>
        <div class="bar" style="margin-top:8px"><div class="bfill" id="prepFill" style="width:0%"></div></div>
        <div class="note">Click to select, Double-click to toggle, Drag to reorder.</div>
      </div>

      <div class="row" id="presets"></div>

      <!-- Main Timer Card -->
      <div class="card" id="mainSpeechCard">
        <div class="row" style="justify-content:space-between">
          <div class="title" id="modeLabel">Substantive Speech</div>
          <div class="muted" id="meta"></div>
        </div>
        <div class="clock" id="clock">3:00</div>
        <div class="progress" id="progress">
          <div class="fill" id="fill"></div>
          <div class="seg" id="segA"></div>
          <div class="seg" id="segB"></div>
          <div class="seg" id="segC"></div>
        </div>
        <div class="caps">
          <div id="capA">0 → 1st: -</div>
          <div id="capB">1st → 2nd: -</div>
          <div id="capC">2nd → Final: -</div>
        </div>
        <div class="row" style="justify-content:center;margin-top:10px">
          <button id="startBtn" class="btn">Start</button>
          <button id="resetBtn" class="btn">Reset</button>
          <button id="singleBtn" class="btn">Single</button>
          <button id="doubleBtn" class="btn">Double</button>
          <button id="stopBellBtn" class="btn" style="display:none">Stop Bell</button>
          <button id="testContBellBtn" class="btn">Test/Stop Cont.</button>
        </div>
        <div class="note" id="statusNote">Status: idle</div>
      </div>

      <div class="grid grid-3">
        <!-- Rebuttal Prep Timer -->
        <div class="card" id="rebuttalPrepCard">
          <div class="title">Rebuttal Prep</div>
          <input id="rprepInput" class="input" value="1:00" />
          <div class="clock" id="rprepClock">1:00</div>
          <div class="bar"><div class="bfill" id="rprepFill" style="width:0%"></div></div>
          <div class="row" style="justify-content:center;margin-top:8px">
            <button id="rprepStart" class="btn">Start</button>
            <button id="rprepReset" class="btn">Reset</button>
          </div>
        </div>
        
        <!-- Reply Timer Card -->
        <div class="card" id="replySpeechCard">
          <div class="title">Reply (3:00)</div>
          <input id="replyInput" class="input" value="3:00" />
          <div class="clock" id="replyClock">3:00</div>
          <div class="bar"><div class="bfill" id="replyFill" style="width:0%"></div></div>
          <div class="row" style="justify-content:center;margin-top:8px">
            <button id="replyStart" class="btn">Start</button>
            <button id="replyReset" class="btn">Reset</button>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="title" style="margin-bottom:8px">Settings</div>
        <div class="grid grid-3">
          <label class="label">Main (m:ss)
            <input id="mainInput" class="input" value="3:00" />
          </label>
          <label class="label">1st Bell from start (m:ss)
            <input id="firstInput" class="input" value="1:00" />
          </label>
          <label class="label">2nd Bell from start (m:ss)
            <input id="secondInput" class="input" value="2:00" />
          </label>
          <label class="label">Yellow at remaining (m:ss)
            <input id="yellowInput" class="input" value="1:00" />
          </label>
          <label class="label">Red at remaining (m:ss)
            <input id="redInput" class="input" value="0:30" />
          </label>
          <label class="label">Grace Period (m:ss)
            <input id="graceInput" class="input" value="0:30" />
          </label>
          <label class="label">Bell spacing (ms)
            <input id="spaceInput" class="input" value="100" />
          </label>
          <label class="label">Bell mode
            <select id="modeSel" class="input">
              <option value="mp3">MP3</option>
              <option value="synth" selected>Synth</option>
            </select>
          </label>
          <label class="label">Volume (0-1)
            <input id="volumeInput" type="range" min="0" max="1" step="0.05" value="0.5" />
          </label>
          <label class="label">MP3 URL
            <input id="mp3Url" class="input" placeholder="https://example.com/bell.mp3" />
          </label>
          <label class="label">Upload MP3
            <input id="mp3File" type="file" accept="audio/*" />
          </label>
        </div>
      </div>

      <div class="card" id="tests" style="display:none">
        <div class="title" style="margin-bottom:6px">Tests</div>
        <ul class="tests" id="testList"></ul>
        <div class="note">Note: Blob URLs from uploads are temporary. Use a public URL to persist across refresh.</div>
      </div>

    </div>
  </div>

<script>
document.addEventListener('touchstart', () => {
  try {
    if (tpeof AudioContext !== 'undefined') {
      const ctx = new AudioContext();
      ctx.resume();
    } else if (typeof webkitAudioContext !== 'undefined') {
      contest ctx = new webkitAudioContext();
      ctx.resume(;)
    }
  } catch (e) {}
}, { once: true });
(function(){
  // ===== Utilities =====
  const $ = sel => document.querySelector(sel);
  const $$ = sel => document.querySelectorAll(sel);
  const fmt = ms => { const t = Math.ceil(ms/1000); const m = Math.floor(t/60); const s = t%60; return `${m}:${String(s).padStart(2,'0')}`; };
  const allDigits = t => !!t && /^[0-9]+$/.test(t);
  const parseMin = input => { const t = (input||'').trim(); if (allDigits(t)) return parseInt(t,10)*60000; const p=t.split(':'); const m=+p[0]||0,s=+p[1]||0; return (m*60+s)*1000 };

  // ===== Speaker Data =====
  const createSpeakerOrder = () => [
    { role: "Prep", initials: "PREP", team: "None", timers: ["prep"], active: true },
    { role: "Prime Minister", initials: "PM", team: "Prop", timers: ["main"], active: true },
    { role: "LO Prep", initials: "R", team: "Opp", timers: ["rebuttal"], active: true },
    { role: "Leader of Opp", initials: "LO", team: "Opp", timers: ["main"], active: true },
    { role: "DPM Prep", initials: "R", team: "Prop", timers: ["rebuttal"], active: true },
    { role: "Deputy PM", initials: "DPM", team: "Prop", timers: ["main"], active: true },
    { role: "DLO Prep", initials: "R", team: "Opp", timers: ["rebuttal"], active: true },
    { role: "Deputy LO", initials: "DLO", team: "Opp", timers: ["main"], active: true },
    { role: "PW Prep", initials: "R", team: "Prop", timers: ["rebuttal"], active: true },
    { role: "Prop Whip", initials: "PW", team: "Prop", timers: ["main"], active: true },
    { role: "OW Prep", initials: "R", team: "Opp", timers: ["rebuttal"], active: true },
    { role: "Opp Whip", initials: "OW", team: "Opp", timers: ["main"], active: true },
    { role: "Opp Reply", initials: "OR", team: "Opp", timers: ["reply"], active: true },
    { role: "Prop Reply", initials: "PR", team: "Prop", timers: ["reply"], active: true },
  ];
  
  let speakerOrder = createSpeakerOrder(); // Make it mutable
  let activeSpeakerIndex = 0;
  let draggingIndex = null;

  // ===== State =====
  const state = {
    preset:'Substantive',
    main: 3*60000,
    first: 60000,
    second: 2*60000,
    yellow: 60000,
    red: 30000,
    grace: 30000,
    spacing: 100, // Changed default
    running:false,
    muted:false,
    mode:'synth', // Changed default
    mp3Url:null,
    volume: 0.5, // Added volume
  };
  
  // This object will hold the timer settings when 'Start' is pressed
  let timerSnapshot = {};

  // Load persisted
  try{
    state.mode = localStorage.getItem('bellMode')||state.mode;
    state.mp3Url = localStorage.getItem('mp3Url')||state.mp3Url;
    state.spacing = parseInt(localStorage.getItem('spacingMs')||state.spacing,10);
    state.volume = parseFloat(localStorage.getItem('volume')||state.volume);
  }catch{}

  // Elements
  const wrap = $('#app');
  const clockEl = $('#clock');
  const metaEl = $('#meta');
  const progressEl = $('#progress');
  const fillEl = $('#fill');
  const segA = $('#segA'), segB=$('#segB'), segC=$('#segC');
  const capA=$('#capA'), capB=$('#capB'), capC=$('#capC');
  const statusNote=$('#statusNote');
  const modeLabel=$('#modeLabel');

  // Inputs
  const mainInput=$('#mainInput'), firstInput=$('#firstInput'), secondInput=$('#secondInput');
  const yellowInput=$('#yellowInput'), redInput=$('#redInput'), graceInput=$('#graceInput');
  const spaceInput=$('#spaceInput');
  const modeSel=$('#modeSel'), mp3Url=$('#mp3Url'), mp3File=$('#mp3File'), volumeInput=$('#volumeInput');

  const muteBtn=$('#muteBtn'), enableBtn=$('#enableBtn'), testsBtn=$('#testsBtn');
  const startBtn=$('#startBtn'), resetBtn=$('#resetBtn');
  const singleBtn=$('#singleBtn'), doubleBtn=$('#doubleBtn');
  const stopBellBtn=$('#stopBellBtn'), testContBellBtn=$('#testContBellBtn');

  // Quick timers
  const prepInput=$('#prepInput'), prepClock=$('#prepClock'), prepFill=$('#prepFill');
  const rprepInput=$('#rprepInput'), rprepClock=$('#rprepClock'), rprepFill=$('#rprepFill');
  const replyInput=$('#replyInput'), replyClock=$('#replyClock'), replyFill=$('#replyFill');
  const prepStart=$('#prepStart'), prepReset=$('#prepReset');
  const rprepStart=$('#rprepStart'), rprepReset=$('#rprepReset');
  const replyStart=$('#replyStart'), replyReset=$('#replyReset');
  
  // Timer Containers
  const prepTimerContainer = $('#prepTimerContainer');
  const mainSpeechCard = $('#mainSpeechCard');
  const rebuttalPrepCard = $('#rebuttalPrepCard');
  const replySpeechCard = $('#replySpeechCard');

  // Presets UI
  const presetsRow = $('#presets');
  const presetBtn = (key,label)=>{
    const b=document.createElement('button'); b.className='btn'; b.textContent=label; b.onclick=()=>applyPreset(key);
    return b;
  };
  // These are now less important as presets are set by speaker
  // presetsRow.appendChild(presetBtn('Substantive','Simson 3:00'));
  // presetsRow.appendChild(presetBtn('Reply','Reply 3:00'));

  // Speaker Progress UI
  const speakerProgress = $('#speakerProgress');
  const nextSpeakerBtn = $('#nextSpeakerBtn');
  const prevSpeakerBtn = $('#prevSpeakerBtn');
  const resetOrderBtn = $('#resetOrderBtn');

  function initSpeakerProgress() {
    speakerProgress.innerHTML = '';
    speakerOrder.forEach((speaker, index) => {
      const box = document.createElement('div');
      box.className = `speaker-box team-${speaker.team.toLowerCase()}`;
      box.classList.toggle('inactive', !speaker.active);
      
      const initials = speaker.initials;
      box.textContent = initials;
      box.title = speaker.role + " (Click to select, Double-click to toggle, Drag to reorder)";
      box.dataset.index = index;
      
      // Click to select
      box.addEventListener('click', () => {
        if (!speaker.active) return; // Don't select inactive
        setActiveSpeaker(index);
      });
      
      // Double-click to toggle active
      box.addEventListener('dblclick', () => {
        speaker.active = !speaker.active;
        box.classList.toggle('inactive', !speaker.active);
      });

      // Drag and Drop
      box.draggable = true;
      box.addEventListener('dragstart', (e) => {
        draggingIndex = index;
        e.dataTransfer.effectAllowed = 'move';
        box.classList.add('dragging');
      });
      box.addEventListener('dragend', () => {
        box.classList.remove('dragging');
        draggingIndex = null;
      });
      box.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        box.classList.add('drag-over');
      });
      box.addEventListener('dragleave', () => {
        box.classList.remove('drag-over');
      });
      box.addEventListener('drop', (e) => {
        e.preventDefault();
        box.classList.remove('drag-over');
        if (draggingIndex === null || draggingIndex === index) return;
        
        // Re-order the array
        const [draggedItem] = speakerOrder.splice(draggingIndex, 1);
        speakerOrder.splice(index, 0, draggedItem);
        
        // Update active index
        if (activeSpeakerIndex === draggingIndex) {
          activeSpeakerIndex = index;
        } else if (draggingIndex < activeSpeakerIndex && index >= activeSpeakerIndex) {
          activeSpeakerIndex--;
        } else if (draggingIndex > activeSpeakerIndex && index <= activeSpeakerIndex) {
          activeSpeakerIndex++;
        }
        
        initSpeakerProgress(); // Redraw all
        setActiveSpeaker(activeSpeakerIndex, true); // Re-apply active class
      });

      speakerProgress.appendChild(box);
    });
  }

  function setActiveSpeaker(index, force = false) {
    if (!force && index === activeSpeakerIndex) return; // No change

    activeSpeakerIndex = index;
    
    // Remove active class from all
    $$('.speaker-box').forEach(box => box.classList.remove('active-speaker'));
    
    // Add active class to current
    const activeBox = $(`[data-index="${index}"]`);
    if (activeBox) {
      activeBox.classList.add('active-speaker');
    }

    // Get speaker and set correct timers
    const speaker = speakerOrder[index];
    if (!speaker) return;
    
    const timers = speaker.timers;
    
    // Hide/Show correct timer cards
    prepTimerContainer.style.display = timers.includes('prep') ? 'flex' : 'none';
    mainSpeechCard.style.display = timers.includes('main') ? 'block' : 'none';
    rebuttalPrepCard.style.display = timers.includes('rebuttal') ? 'block' : 'none';
    replySpeechCard.style.display = timers.includes('reply') ? 'block' : 'none';

    // Apply correct preset
    if (timers.includes('main')) {
      applyPreset('Substantive');
    } else if (timers.includes('reply')) {
      applyPreset('Reply');
    }
  }

  function findNextSpeaker(direction) {
    let newIndex = activeSpeakerIndex;
    const max = speakerOrder.length - 1;
    
    for (let i = 1; i <= speakerOrder.length; i++) {
      newIndex = (newIndex + direction + speakerOrder.length) % speakerOrder.length;
      if (speakerOrder[newIndex].active) {
        return newIndex;
      }
    }
    return activeSpeakerIndex; // No other active speaker
  }

  nextSpeakerBtn.onclick = () => {
    const nextIndex = findNextSpeaker(1);
    setActiveSpeaker(nextIndex);
  };
  
  prevSpeakerBtn.onclick = () => {
    const prevIndex = findNextSpeaker(-1);
    setActiveSpeaker(prevIndex);
  };

  resetOrderBtn.onclick = () => {
    speakerOrder = createSpeakerOrder();
    initSpeakerProgress();
    setActiveSpeaker(0);
  };

  // ===== Audio =====
  const SILENT_WAV = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=';
  let audioCtx = null; // AudioContext
  let unlocked = false;

  const getOrCreateContext = async()=>{
    if(state.muted) { setStatus('muted'); return null; }
    const Ctx = window.AudioContext || window.webkitAudioContext; if(!Ctx){ setStatus('no-audiocontext'); return null; }
    if(!audioCtx){ try{ audioCtx = new Ctx(); }catch{ setStatus('no-audiocontext'); return null; } }
    if(audioCtx && audioCtx.state==='suspended'){ try{ await audioCtx.resume(); }catch{} }
    return audioCtx;
  };

  const playSilent = async()=>{ try{ const a=new Audio(SILENT_WAV); a.muted=true; await a.play(); a.pause(); a.currentTime=0; return true; }catch{ return false; } };

  const setStatus = (s)=>{ statusNote.textContent = 'Status: '+s + (state.mode==='mp3' && !state.mp3Url ? ' · Tip: set a public MP3 URL or upload below' : ''); };

  const unlock = async()=>{
    const ctx = await getOrCreateContext();
    const tagOk = await playSilent();
    const ctxOk = !!ctx && ctx.state==='running';
    if(ctxOk || tagOk){ unlocked=true; setStatus(state.mode==='mp3' && !state.mp3Url ? 'armed':'ready'); return true; }
    setStatus('blocked'); return false;
  };

  const playBell = async(count)=>{
    if(state.muted) return;
    const ok = await unlock(); if(!ok) return;
    if(state.mode==='synth'){
      const ctx = audioCtx; if(!ctx) return;
      const base = ctx.currentTime + .05;
      const t = base; // Play all at once for a chord
      
      // E Minor 7th chord (E, G, B, D)
      // E4: 329.63 Hz, G4: 392.00 Hz, B4: 493.88 Hz, D5: 587.33 Hz
      // Let's use a higher voicing for a "bell"
      // E5: 659.26, G5: 783.99, B5: 987.77, D6: 1174.66
      const freqs = [659.26, 783.99, 987.77, 1174.66];
      
      const master = ctx.createGain();
      master.gain.setValueAtTime(0.0001, t);
      master.gain.exponentialRampToValueAtTime(state.volume, t + 0.02); // Fixed: Louder
      master.gain.exponentialRampToValueAtTime(0.0001, t + 2.5); // Longer decay
      master.connect(ctx.destination);

      for (let i = 0; i < count; i++) {
        const time = t + (i * state.spacing) / 1000;
        freqs.forEach((freq, idx) => {
          const osc = ctx.createOscillator();
          const g = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, time);
          
          // Vary gain and decay for each partial
          const partialGain = state.volume * (1 - (idx * 0.15));
          const decay = 2.0 - (idx * 0.3);
          
          g.gain.setValueAtTime(partialGain, time);
          g.gain.exponentialRampToValueAtTime(0.0001, time + decay);
          
          osc.connect(g).connect(master);
          osc.start(time);
          osc.stop(time + 2.5);
        });
      }
    } else {
      for(let i=0;i<count;i++) setTimeout(()=>{ try{ const a=new Audio(state.mp3Url); a.volume=state.volume; a.play().catch(()=>{}); }catch{} }, i*state.spacing);
    }
  };

  // Controls
  muteBtn.onclick = ()=>{ state.muted=!state.muted; muteBtn.textContent = state.muted? 'Muted':'Sound'; };
  enableBtn.onclick = unlock;
  testsBtn.onclick = ()=>{ const box=$('#tests'); box.style.display = box.style.display==='none'?'block':'none'; };

  // ===== Main Timer Engine =====
  let startTs=null, acc=0, raf=null, remaining=state.main;
  let inGrace=false, graceRemaining=0;
  let contBellInterval=null;
  const fired = {first:false, second:false, final:false};

  // Stop continuous bell
  const stopContinuousBell = ()=>{
    if(contBellInterval){ clearInterval(contBellInterval); contBellInterval=null; }
    stopBellBtn.style.display = 'none';
    testContBellBtn.textContent = 'Test/Stop Cont.';
  };

  // Wire up stop button
  stopBellBtn.onclick = stopContinuousBell;
  testContBellBtn.onclick = ()=>{
    if(contBellInterval){
      stopContinuousBell();
    } else {
      unlock();
      contBellInterval = setInterval(()=>playBell(1), 500);
      testContBellBtn.textContent = 'Stop';
    }
  };

  const loop = (ts)=>{
    if(startTs===null) startTs=ts;
    const elapsed = (ts-startTs)+acc;
    
    if (inGrace) {
      // We are in the grace period
      graceRemaining = Math.max(0, timerSnapshot.grace - elapsed);
      remaining = 0;
      if (graceRemaining === 0) {
        // Grace period over
        if (!contBellInterval && timerSnapshot.preset === 'Substantive') {
          // Start continuous bell only for Substantive
          contBellInterval = setInterval(()=>playBell(1), 500); // 500ms interval
          stopBellBtn.style.display = 'inline-flex';
        }
      }
    } else {
      // We are in the main countdown
      remaining = Math.max(0, timerSnapshot.main - elapsed);
      if (remaining === 0) {
        if (!fired.final) {
          playBell(2);
          fired.final = true;
        }
        // Transition to grace period
        inGrace = true;
        acc = 0; // Reset accumulator for grace period
        startTs = ts; // Reset start time for grace period
      }
    }
    
    render();
    
    // Check bells during main countdown
    if (!inGrace) {
      checkBells();
    }
    
    // Only continue loop if main time or grace time is left
    if (remaining > 0 || graceRemaining > 0) {
      raf = requestAnimationFrame(loop);
    } else {
      // Loop finishes (unless continuous bell is on)
      cancelAnimationFrame(raf);
      raf = null;
    }
  };

  const snapshotSettings = () => {
    timerSnapshot = {
      main: state.main,
      first: state.first,
      second: state.second,
      yellow: state.yellow,
      red: state.red,
      grace: state.grace,
      preset: state.preset, // Snapshot preset type
    };
  };

  const start = ()=>{
    if(raf) return;
    if (acc === 0) { // If it's a fresh start (not resume)
      snapshotSettings(); // Take snapshot of settings
      inGrace = false;
      graceRemaining = timerSnapshot.grace;
    }
    requestAnimationFrame(loop);
  };
  
  const pause = ()=>{
    if(!raf) return;
    cancelAnimationFrame(raf);
    raf = null;
    const now = performance.now();
    acc += (now - startTs);
    startTs = null;
    stopContinuousBell(); // Stop bells on pause
  };
  
  const reset = ()=>{
    if(raf) cancelAnimationFrame(raf);
    raf = null;
    startTs = null;
    acc = 0;
    inGrace = false;
    // Reset to the *last snapped* settings
    remaining = timerSnapshot.main || state.main; 
    graceRemaining = timerSnapshot.grace || state.grace;
    fired.first = fired.second = fired.final = false;
    stopContinuousBell(); // Stop bells on reset
    render(true); // Force render with state, not snapshot
  };

  // Buttons
  startBtn.onclick = ()=>{ 
    unlock(); 
    if(raf) { 
      pause(); 
      startBtn.textContent = 'Start'; 
    } else { 
      start(); 
      startBtn.textContent = 'Pause'; 
    } 
  };
  resetBtn.onclick = ()=>{ pause(); reset(); startBtn.textContent='Start'; };
  singleBtn.onclick = ()=>{ unlock(); playBell(1); };
  doubleBtn.onclick = ()=>{ unlock(); playBell(2); };

  // Inputs handlers
  const syncFromInputs = ()=>{
    state.main = parseMin(mainInput.value);
    state.first = parseMin(firstInput.value);
    state.second = parseMin(secondInput.value);
    state.yellow = parseMin(yellowInput.value);
    state.red = parseMin(redInput.value);
    state.grace = parseMin(graceInput.value);
    state.spacing = Math.max(100, parseInt(spaceInput.value||'100',10)||100);
    state.mode = modeSel.value;
    state.volume = parseFloat(volumeInput.value);
    if(mp3Url.value) state.mp3Url = mp3Url.value;
    
    localStorage.setItem('bellMode', state.mode);
    if(state.mp3Url) localStorage.setItem('mp3Url', state.mp3Url);
    localStorage.setItem('spacingMs', String(state.spacing));
    localStorage.setItem('volume', String(state.volume));
    
    // Only reset if timer is not running
    if (!raf) {
      reset();
    }
    
    modeLabel.textContent = state.preset==='Substantive'? 'Substantive Speech':'Reply Speech';
  };
  
  // Apply initial values from state to inputs
  mainInput.value = fmt(state.main);
  firstInput.value = fmt(state.first);
  secondInput.value = fmt(state.second);
  yellowInput.value = fmt(state.yellow);
  redInput.value = fmt(state.red);
  graceInput.value = fmt(state.grace);
  spaceInput.value = state.spacing;
  modeSel.value = state.mode;
  volumeInput.value = state.volume;
  if (state.mp3Url) mp3Url.value = state.mp3Url;
  
  // Add listeners
  [mainInput,firstInput,secondInput,yellowInput,redInput,graceInput,spaceInput,modeSel,mp3Url,volumeInput].forEach(el=> el.addEventListener('change', syncFromInputs));
  mp3File.addEventListener('change', (e)=>{ const f=e.target.files&&e.target.files[0]; if(f){ const url=URL.createObjectURL(f); state.mp3Url=url; mp3Url.value=url; } });

  // Presets
  function applyPreset(key){
    state.preset=key;
    if(key==='Substantive'){ 
      mainInput.value='3:00'; firstInput.value='1:00'; secondInput.value='2:00'; 
      yellowInput.value='1:00'; redInput.value='0:30'; graceInput.value='0:30'; 
    }
    else { // Reply
      mainInput.value='3:00'; firstInput.value='0:00'; secondInput.value='0:00'; 
      yellowInput.value='0:30'; redInput.value='0:15'; graceInput.value='0:00'; 
    }
    syncFromInputs();
  }

  // Quick timers helper
  function miniTimer(inputEl, clockEl, fillEl, endBellCount = 0){
    let dur = parseMin(inputEl.value);
    let snapshotDur = dur; // Snapshot duration on start
    let rem=dur; 
    let st=null, acc=0, r=null;
    
    const paint = ()=>{ 
      clockEl.textContent = fmt(rem); 
      const pct = snapshotDur === 0 ? 0 : 100 - Math.round((rem/snapshotDur)*100); 
      fillEl.style.width = Math.max(0,Math.min(100,pct))+"%"; 
    };
    
    const lp = (ts)=>{ 
      if(st===null) st=ts; 
      const el=(ts-st)+acc; 
      rem=Math.max(0,snapshotDur-el); 
      paint(); 
      if(rem>0) {
        r=requestAnimationFrame(lp); 
      } else {
        cancelAnimationFrame(r);
        r = null;
        if (endBellCount > 0) {
          playBell(endBellCount);
        }
      }
    };
    
    const start=()=>{ 
      if(r) return; 
      if (acc === 0) { // Fresh start
        snapshotDur = parseMin(inputEl.value);
      }
      rem = snapshotDur - acc;
      requestAnimationFrame(lp); 
    };
    const pause=()=>{ 
      if(!r) return; 
      cancelAnimationFrame(r); 
      r=null; 
      const now=performance.now(); 
      acc+=(now-st); 
      st=null; 
    };
    const reset=()=>{ 
      if(r) cancelAnimationFrame(r); 
      r=null; st=null; acc=0; 
      dur=parseMin(inputEl.value); 
      snapshotDur = dur; // Reset snapshot
      rem=dur; 
      paint(); 
    };
    
    inputEl.addEventListener('change', ()=>{ 
      dur = parseMin(inputEl.value); 
      if (!r) { // Only reset if not running
        reset(); 
      }
    });
    paint();
    return { start, pause, reset };
  }
  
  // Pass end bell count
  const prep = miniTimer(prepInput, prepClock, prepFill, 1);
  const rprep = miniTimer(rprepInput, rprepClock, rprepFill, 1);
  const reply = miniTimer(replyInput, replyClock, replyFill, 2);
  
  // Prep timer buttons
  prepStart.onclick = ()=>{ if(prepStart.textContent==='Start'){ prep.start(); prepStart.textContent='Pause'; } else { prep.pause(); prepStart.textContent='Start'; } };
  prepReset.onclick = ()=>{ prep.reset(); prepStart.textContent='Start'; };
  
  // Rebuttal prep buttons
  rprepStart.onclick = ()=>{ if(rprepStart.textContent==='Start'){ rprep.start(); rprepStart.textContent='Pause'; } else { rprep.pause(); rprepStart.textContent='Start'; } };
  rprepReset.onclick = ()=>{ rprep.reset(); rprepStart.textContent='Start'; };

  // Reply timer buttons
  replyStart.onclick = ()=>{ if(replyStart.textContent==='Start'){ reply.start(); replyStart.textContent='Pause'; } else { reply.pause(); replyStart.textContent='Start'; } };
  replyReset.onclick = ()=>{ reply.reset(); replyStart.textContent='Start'; };

  // Render main
  function render(forceState = false){
    // Use snapshot if timer is running, otherwise use current state
    const source = (raf && !forceState) ? timerSnapshot : state;
    
    const total = source.main;
    const currentRemaining = inGrace ? graceRemaining : remaining;
    
    clockEl.textContent = fmt(currentRemaining);
    if (inGrace) {
      clockEl.textContent = '-' + fmt(graceRemaining);
    }
    
    // background color by thresholds
    const bg = currentRemaining <= source.red ? 'var(--bg-red)' : currentRemaining <= source.yellow ? 'var(--bg-yellow)' : 'var(--bg-green)';
    const fg = currentRemaining <= source.red ? 'var(--fg-red)' : currentRemaining <= source.yellow ? 'var(--fg-yellow)' : 'var(--fg-green)';
    const bd = currentRemaining <= source.red ? 'var(--bd-red)' : currentRemaining <= source.yellow ? 'var(--bd-yellow)' : 'var(--bd-green)';
    
    if (inGrace) {
      // Flashing red for grace period
      const flash = Math.floor(performance.now() / 500) % 2 === 0;
      wrap.style.background = flash ? 'var(--bg-red)' : 'var(--bg-card)';
      wrap.style.color = flash ? 'var(--fg-red)' : 'var(--fg)';
      document.documentElement.style.setProperty('--bd', flash ? 'var(--bd-red)' : 'var(--bd-green)');
    } else {
      wrap.style.background = bg;
      wrap.style.color = fg;
      document.documentElement.style.setProperty('--bd', bd);
    }

    // progress segments
    const a = Math.min(source.first || 0, total);
    const b = Math.min(Math.max(0, (source.second || 0) - (source.first || 0)), total);
    const c = Math.max(0, total - (a + b));
    const pct = n => total === 0 ? 0 : (n/total)*100;
    const fillPct = total === 0 ? 100 : pct(total-remaining);
    
    fillEl.style.width = fillPct+"%";
    segA.style.width = pct(a)+"%"; segB.style.width = pct(b)+"%"; segC.style.width = pct(c)+"%";

    capA.textContent = `0 → 1st: ${source.first?fmt(source.first):'-'}`;
    capB.textContent = `1st → 2nd: ${(source.first&&source.second)?fmt(source.second-source.first):'-'}`;
    capC.textContent = `2nd → Final: ${source.second?fmt(total-source.second):fmt(total-(source.first||0))}`;

    metaEl.textContent = `Main: ${fmt(total)}${source.first?` · 1st ${fmt(source.first)}`:''}${source.second?` · 2nd ${fmt(source.second)}`:''}`;
    
    if (inGrace) {
      metaEl.textContent = `GRACE PERIOD: ${fmt(source.grace)}`;
    }
  }

  // Fire bells as elapsed passes markers
  function checkBells(){
    const elapsed = timerSnapshot.main - remaining;
    if(!fired.first && timerSnapshot.first>0 && elapsed>=timerSnapshot.first){ playBell(1); fired.first=true; }
    if(!fired.second && timerSnapshot.second>0 && elapsed>=timerSnapshot.second){ playBell(1); fired.second=true; } // Fixed typo here
  }
  
  // (We don't need to augment the loop, the main `loop` function already calls checkBells)

  // Initial paint
  snapshotSettings(); // Create an initial snapshot
  render(true); // Force render from state
  initSpeakerProgress(); // Build speaker UI
  setActiveSpeaker(0); // Set to first speaker

  // ===== Tests =====
  const tests = [
    {name:'formatTime 61000 -> 1:01', run:()=> fmt(61000)==='1:01'},
    {name:'parse m:ss 2:30 -> 150000', run:()=> parseMin('2:30')===150000},
    {name:'parse m only 3 -> 180000', run:()=> parseMin('3')===180000},
    {name:'threshold order yellow>red', run:()=> 60000>30000},
    {name:'spacing clamp', run:()=> Math.max(100,parseInt('60',10)||100)===100},
    {name:'parse 0:05 -> 5000', run:()=> parseMin('0:05')===5000},
    {name:'parse 0 -> 0', run:()=> parseMin('0')===0},
    {name:'AudioContext guard (presence boolean)', run:()=> typeof (window.AudioContext||window.webkitAudioContext)!=='undefined' || true },
  ];
  const testList = $('#testList');
  const showTests = ()=>{ testList.innerHTML=''; tests.forEach(t=>{ const li=document.createElement('li'); let ok=false; try{ ok=t.run(); }catch{ ok=false } li.textContent=(ok?'PASS ':'FAIL ')+t.name; li.style.color=ok?'#065f46':'#7f1d1d'; testList.appendChild(li); }); };
  testsBtn.addEventListener('click', showTests);

})();
</script>
<script>
  let wakeLock = null;
  async function keepAwake() {
    try {
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
      }
    } catch (err) {
      console.log('Wake lock not supported:', err);
    }
  }
  document.addEventListener('visibilitychange', async () => {
    if (wakeLock !== null && document.visibilityState === 'visible') {
      await keepAwake();
    }
  });
  keepAwake();
</script>
</body>
</html>

